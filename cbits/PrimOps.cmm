#include "Cmm.h"
#include "MachDeps.h"

/*
 * Prim ops to convert floating point values to integral values of the same size
 * preserving the bits of the floating point values and back again.
 * Currently we do this by storing the value on the stack and reading it back
 * again (to get from one set of registers to another).
 */

#if SIZEOF_DOUBLE != 8
#error "SIZEOF_DOUBLE != 8"
#endif

#if SIZEOF_FLOAT != 4
#error "SIZEOF_FLOAT != 4"
#endif

#if SIZEOF_VOID_P == 8
#define __64BITS
#elif SIZEOF_VOID_P == 4
#define __32BITS
#error "32 Bit currently does not really work (although it should). If you want to try nonetheless, remove this line."
#else
#error "Only 32 or 64 bit targets are supported"
#endif

/*
 * Get the bits of a double by saving it to the stack and reading it back.
 */
double2WordBwzh
{
#ifdef __64BITS
    P_ j;
    j = P_[Sp];
    D_[Sp] = D1;
    R1 = I64[Sp];
    jump (j) [R1];
#else
    P_ j;
    I32 tmp;
    j = P_[Sp];
    tmp = I32[Sp-4];
    D_[Sp-4] = D1;
    R1 = I64[Sp-4];
    I32[Sp-4] = tmp;
    jump (j) [R1];
#endif
}

/*
 * Convert some bits to a double by saving it to the stack and reading it back.
 */
word2DoubleBwzh
{
#ifdef __64BITS
    P_ j;
    j = P_[Sp];
    I64[Sp] = R1;
    D1 = D_[Sp];
    jump (j) [D1];
#else
    P_ j;
    I32 tmp;
    j = P_[Sp];
    tmp = I32[Sp-4];
    I64[Sp-4] = R1;
    D1 = D_[Sp-4];
    I32[Sp-4] = tmp;
    jump (j) [R1];
#endif
}

/*
 * Get the bits of a float by saving it to the stack and reading it back.
 */
float2WordBwzh
{
    P_ j;
    j = P_[Sp];
    F_[Sp] = F1;
    R1 = I32[Sp];
    jump (j) [R1];
}

/*
 * Convert some bits to a float by saving it to the stack and reading it back.
 */
word2FloatBwzh
{
    P_ j;
    j = P_[Sp];
    I32[Sp] = R1;
    F1 = F_[Sp];
    jump (j) [F1];
}
